"""This module deals with loading/downloading pyluxcore."""

import pathlib
import os
import itertools
import sys
import subprocess
import shutil
from textwrap import dedent
import base64
import hashlib
from enum import Enum, IntEnum
import types
import json
import configparser

import bpy
import addon_utils

from .. import utils

# The variable PYLUXCORE_VERSION specifies the release version of pyluxcore
# that will be downloaded from PyPi during the standard installation of
# BlendLuxCore. Please update this variable ONLY after the targeted version of
# pyluxcore has been released on PyPi.
PYLUXCORE_VERSION = "2.11.0-dev0"

# User folders
ROOT_FOLDER = utils.get_user_dir("")
WHEEL_DL_FOLDER = utils.get_user_dir("wheels")
WHEEL_BACKUP_FOLDER = utils.get_user_dir("wheels_backup")

# Settings file
SETTINGS_FOLDER = pathlib.Path(
    bpy.utils.user_resource("CONFIG", path="BlendLuxCore", create=True)
)
SETTINGS_FILENAME = "blc_settings.json"
SETTINGS_FILEPATH = SETTINGS_FOLDER / SETTINGS_FILENAME


def _hash_wheels(wheels):
    """Hash a collection of wheel requirements.

    Wheel requirement valid types are `pathlib.Path` or `str`:
    - Path('/tmp/pyluxcore-2.11.0-cp313-cp313-linux_x86_64.whl')
    - str("pyluxcore==2.10.1")
    - ...

    """
    wheel_hash = hashlib.sha256()
    for wheel in wheels:
        if isinstance(wheel, str):
            wheel_hash.update(wheel.encode())
        elif isinstance(wheel, pathlib.Path):
            with wheel.open("rb") as fwheel:
                wheel_hash = hashlib.file_digest(fwheel, lambda: wheel_hash)
        else:
            raise TypeError("Unhandled Wheel requirement type")
    return wheel_hash.hexdigest()


def _download_wheels(wheel_requirements, no_deps, no_index):
    """Download wheels from wheel requirements."""
    no_deps = bool(no_deps)
    no_index = bool(no_index)

    for wheel_requirement in wheel_requirements:
        command = [
            sys.executable,
            "-m",
            "pip",
            "download",
            wheel_requirement,
            "-d",
            WHEEL_DL_FOLDER,
        ]
        if no_deps:
            command.append("--no-deps")
        if no_index:
            command.append("--no-index")

        process = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            check=True,
        )

        if output := process.stdout.decode():
            print("[BLC] Downloading wheel:\n", output)

        if process.returncode:
            raise RuntimeError(
                "[BLC] Failed to download LuxCore with return code "
                f"{process.returncode}."
            )


INSTALL_INFO_HEADER = """\
# This file is intended to store information about pyluxcore installation.
# It is used to determine whether a new installation is necessary at each
# startup.
# Only one entry should be different from 'None', it indicates from which
# source the installation was taken.
#
# This file is automatically generated and should not be edited manually.\n
"""


def _save_installation_info(whl_hash):
    """Save information from the last installation.

    Only one of the supplied arguments should be different from 'None'
    to ensure that the type of installation is saved implicitly as well.
    """
    assert whl_hash
    info_file = ROOT_FOLDER / "pyluxcore_installation_info.txt"
    config = configparser.ConfigParser()
    config["WHEELS"] = {"hash": whl_hash}

    with open(info_file, "w", encoding="utf-8") as f:
        f.write(INSTALL_INFO_HEADER)
        config.write(f)


def _get_installation_info():
    """Check the version to install against the last installed version.

    Compare the version to be installed with the description saved during the
    last install. If they match, installation is skipped for efficiency.
    """
    # Read the file
    info_file = ROOT_FOLDER / "pyluxcore_installation_info.txt"
    print(f"[BLC] Checking installation info ('{info_file}')")

    if not info_file.exists:
        return None

    config = configparser.ConfigParser()
    try:
        config.read([info_file], encoding="utf-8")
    except FileNotFoundError:
        return None
    except configparser.MissingSectionHeaderError:
        print("[BLC] - Warning - Malformed info file")
        return None

    try:
        old_wheel_hash = config["WHEELS"]["hash"]
    except KeyError:
        print("[BLC] Warning - Missing hash in info file content")
        return None

    return old_wheel_hash


def _clear_wheels():
    """Remove wheel files from wheel download folder."""
    files = os.listdir(WHEEL_DL_FOLDER)
    for file in files:
        os.remove(WHEEL_DL_FOLDER / file)


def _backup_wheels():
    """Backup any wheels from a previously successful installation."""
    files = os.listdir(WHEEL_DL_FOLDER)
    for file in files:
        shutil.move(WHEEL_DL_FOLDER / file, WHEEL_BACKUP_FOLDER / file)


def _delete_backup_wheels():
    """Remove all backup wheels from previously successful installation."""
    files = os.listdir(WHEEL_BACKUP_FOLDER)
    for file in files:
        os.remove(WHEEL_BACKUP_FOLDER / file)


def _restore_backup_wheels():
    """Remove backup wheels from previously successful installation.

    Backup wheels are removed from wheel folder.
    """
    files = os.listdir(WHEEL_BACKUP_FOLDER)
    for file in files:
        shutil.move(WHEEL_BACKUP_FOLDER / file, WHEEL_DL_FOLDER / file)


def _check_offline_content(install_offline_folder):
    """Check if offline folder contains something to install."""
    files = os.listdir(install_offline_folder)
    if len(files) == 0:
        raise RuntimeError(
            "BlendLuxCore Installation Error: "
            "The install_offline/ directory exists but is empty!"
        )

    versions = (f.split("-")[1] for f in files if f.startswith("pyluxcore"))
    for version in versions:
        break
    else:
        version = None  # no valid file was found
    return version


def _copy_offline_files(install_offline_folder):
    """Copy offline folder content to wheel folder."""
    files = os.listdir(install_offline_folder)
    for file in files:
        shutil.copy(install_offline_folder / file, WHEEL_DL_FOLDER / file)


def _delete_install_offline(install_offline_folder):
    """Clear offline folder content."""
    files = os.listdir(install_offline_folder)
    for file in files:
        os.remove(install_offline_folder / file)
    os.rmdir(install_offline_folder)


DEFAULT_SETTINGS = {
    "wheel_source": 0,
    "wheel_version": "",
    "path_to_wheel": "",
    "path_to_folder": "",
    "reinstall_upon_reloading": False,
}


def _get_settings():
    """Get pyluxcore loading settings from settings file.

    We first try to import a settings file (typically provided by
    BlendLuxHelper) and, if it fails, we fall back to default settings.
    """
    try:
        with open(SETTINGS_FILEPATH, "r", encoding="utf-8") as fsettings:
            print(f"[BLC] Found wheel settings file ('{SETTINGS_FILEPATH}').")
            return json.load(fsettings)
    except FileNotFoundError:
        # Pass silently: settings file is optional, so not finding it is not an
        # error
        return DEFAULT_SETTINGS
    except OSError as err:
        # Warn and pass
        print(
            "[BLC] Warning: system error while trying to open settings file: "
            f"'{err}'"
        )
        return DEFAULT_SETTINGS
    except (json.JSONDecodeError, UnicodeDecodeError) as err:
        # Warn and pass
        print(f"[BLC] Warning: cannot decode settings file: '{err}'")
        return DEFAULT_SETTINGS


def _install_wheels():
    """Install wheels in Blender from download folder."""
    extensions_directory = pathlib.Path(bpy.utils.user_resource("EXTENSIONS"))
    if not (wheel_list := [("blendluxcore", list(WHEEL_DL_FOLDER.iterdir()))]):
        raise ValueError("[BLC] ERROR - No wheel to install.")

    # We use Blender internal feature to install the wheels
    # pylint: disable=protected-access
    addon_utils._initialize_extensions_compat_ensure_up_to_date_wheels(
        extensions_directory,
        wheel_list,
        bpy.app.debug_python,
        error_fn=lambda ex: print("Error:", str(ex)),
    )


class WheelSource(IntEnum):
    """Permitted values for wheel source (from BlendLuxHelper)."""

    PYPI = 0
    LOCAL = 1
    LOCALDEPS = 2


class FetchWheelStatus(IntEnum):
    """Enumeration of return statuses for _fetch_wheels."""

    OK = 0
    ERROR = 1
    CACHE = 2


ENSURE_ERROR_MSG = """\
[BLC] WARNING: Download of pyluxcore not successful... Falling back to wheels
already in cache."""


def _fetch_wheels():
    """Fetch wheels from their locations.

    Fetching means either downloading or copying from local source, depending
    on settings. Wheels are just gathered in a given directory, not installed.
    """
    # Get settings
    settings = _get_settings()

    wheel_source = settings.get("wheel_source", 0)
    reinstall_upon_reloading = bool(settings.get("reinstall_upon_reloading", False))
    no_deps = bool(settings.get("no_deps", False))
    no_index = bool(settings.get("no_index", False))

    # Get installation info for comparison in the following steps
    old_wheel_hash = _get_installation_info()

    # Case #1 (standard case): Get wheel from PyPI
    if wheel_source == WheelSource.PYPI:
        # Compute required version
        pyluxcore_version = settings.get("wheel_version") or PYLUXCORE_VERSION

        wheels = [f"pyluxcore=={pyluxcore_version}"]

        print("[BLC] Installing pyluxcore version:", pyluxcore_version)

    # Case #2: Get from local source (1 file)
    elif wheel_source == WheelSource.LOCAL:
        # Get path to wheel and check consistency
        path_to_wheel = pathlib.Path(settings.get("path_to_wheel", ""))
        if not (path_to_wheel.is_file() and path_to_wheel.is_absolute()):
            print(f"[BLC] Wheel file not found ('{path_to_wheel}')")
            return FetchWheelStatus.ERROR, None

        # Get optional folder with dependencies
        additional_deps = []
        if path_to_wheel_deps_setting := settings.get("path_to_wheel_deps", ""):
            path_to_wheel_deps = pathlib.Path(path_to_wheel_deps_setting)
            if (
                path_to_wheel_deps.is_dir()
                and path_to_wheel_deps.is_absolute()
            ):
                additional_deps = list(path_to_wheel_deps.glob("*.whl"))
            else:
                print(
                    "[BLC] Additional deps folder is not valid "
                    f"('{path_to_wheel_deps}') - Skipping"
                )

        # Set wheel list
        wheels = additional_deps + [path_to_wheel]

        print(
            f"[BLC] Installing local version of pyluxcore ('{path_to_wheel}')"
        )

    # No other case
    else:
        raise ValueError(f"Unhandled wheel source setting ({wheel_source})")

    # Check cache (hash and compare)
    wheel_hash = _hash_wheels(wheels)
    if not reinstall_upon_reloading and wheel_hash == old_wheel_hash:
        return FetchWheelStatus.CACHE, wheel_hash

    # Download
    _backup_wheels()
    try:
        _download_wheels(wheels, no_deps, no_index)
    except Exception as err:
        print(f"[BLC] Unexpected {err=}, {type(err)=}")
        _clear_wheels()
        _restore_backup_wheels()
        result = FetchWheelStatus.ERROR, None
    else:
        result = FetchWheelStatus.OK, wheel_hash
    finally:
        _delete_backup_wheels()

    return result


def ensure_pyluxcore():
    """Ensure pyluxcore is duly installed.

    This is a prerequisite for being able to import pyluxcore into the rest of
    BlendLuxCore.
    We cannot 'pip install' directly, as it would install pyluxcore
    system-wide, not just in Blender environment. Blender has got its own logic
    for wheel installation, we must rely on it.
    The source which we must fetch wheels from is to be found in settings.
    """

    print("[BLC] Ensuring pyluxcore")

    # Fetch wheels (download or copy from local source, depending on settings)
    # and install them
    fetch_result, wheel_hash = _fetch_wheels()

    if fetch_result == FetchWheelStatus.OK:
        # Install wheels
        print("[BLC] Installing wheel(s)")
        try:
            _install_wheels()
        except ValueError:
            print("[BLC] No wheel installed - BlendLuxCore may be unusable")
        else:
            _save_installation_info(wheel_hash)
    elif fetch_result == FetchWheelStatus.CACHE:
        # Wheels have been found in cache and thus are already installed:
        # => Nothing to do
        print(
            "[BLC] Skipping pyluxcore installation. Similar wheel(s) already "
            "installed."
        )
    elif fetch_result == FetchWheelStatus.ERROR:
        print(ENSURE_ERROR_MSG)
